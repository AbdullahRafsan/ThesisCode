# -*- coding: utf-8 -*-
"""DCT-T

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QWGwhlKDQ2pP_OcfU7esrKnNn0SHiGrf

#DCT-based Image Compression

Here we explore image compression using the Discrete Cosine Transform, as is
used in some JPEG compression algorithms. Let's install graph learning and
load the cameraman image.
"""

import matplotlib.pyplot as plt
import numpy as np
import cv2
import time

patch_size = 8  # 8x8 patch


def get_dct(image='work/original/cameraman.tif'):
    # Load image
    original_image = np.float32(cv2.imread(image, cv2.IMREAD_GRAYSCALE))

    if __name__ == "__main__":
        plt.figure(figsize=(10, 10))
        plt.title = 'Original Image'
        plt.imshow(original_image, cmap='gray')
        plt.show(block=False)

    if __name__ == "__main__":
        # Check data type of image
        print('Data type: ' + str(original_image.dtype))
        print('Pixel intensity range: (%d,%d)' % (original_image.min(), original_image.max()))

        # Print image shape
        print(original_image.shape)

    # Let's now take the DCT of the patches in the image.

    dct_transformed_image = np.zeros_like(original_image)
    s = time.time()
    for row in range(0, original_image.shape[0], patch_size):
        for column in range(0,original_image.shape[1], patch_size):
            dct_transformed_image[row:(row+patch_size), column:(column+patch_size)] = cv2.dct(original_image[row:(row+patch_size), column:(column+patch_size)])

    # Let's now compress the image by thresholding the smaller coefficients to zero.

    thresh = 0.1
    thresholded_image = dct_transformed_image * (np.absolute(dct_transformed_image) > thresh*np.max(np.absolute(dct_transformed_image)))
    e = time.time()
    compression_time = e - s

    if __name__ == "__main__":
        # Let's plot the DCT transformed image
        plt.figure(figsize=(10, 10))
        plt.imshow(dct_transformed_image, cmap='gray', vmin=0, vmax=np.max(dct_transformed_image)*0.01)
        plt.show(block=False)

    # We now decompress the image by taking the inverse DCT.
    reconstructed_image = np.zeros_like(original_image)
    s = time.time()
    for row in range(0, original_image.shape[0], patch_size):
        for column in range(0, original_image.shape[1], patch_size):
            reconstructed_image[row:(row+patch_size), column:(column+patch_size)] = cv2.idct(thresholded_image[row:(row+patch_size), column:(column+patch_size)])
    e = time.time()
    decompression_time = e - s

    # Compute compression ratio
    compression_ratio = original_image.size / np.sum(reconstructed_image != 0.0)
    if __name__ == "__main__":
        print('Compression ratio: %.1f:1' % (compression_ratio))

    # Compute Peak Signal to Noise Ratio (PSNR)
    MSE = np.sum((original_image-reconstructed_image)**2)/original_image.size
    PSNR = 10*np.log10(np.max(original_image)**2/MSE)
    if __name__ == "__main__":
        print('PSNR: %.2f dB' % PSNR)

    if __name__ == "__main__":
        # Plot decompressed (reconstructed image)
        plt.figure(figsize=(10, 10))
        plt.subplot(1, 3, 1)
        plt.imshow(original_image, cmap='gray')
        plt.subplot(1, 3, 2)
        plt.imshow(reconstructed_image, cmap='gray')
        plt.subplot(1, 3, 3)
        plt.imshow(original_image-reconstructed_image, cmap='gray')
        plt.show(block=False)

    return (compression_ratio, compression_time, decompression_time, MSE, PSNR, reconstructed_image)


get_dct()
